VISION AND MISSION OF THE INSTITUTE 
 
VISION 
 
Carving the youth as dynamic, complement, valued and knowledgeable professionals who shall lead the nation to a better future. 
 
MISSION 
 
‚Ä¢	Providing quality education, Student ‚Äì Centered teaching ‚Äì Learning process and state - of ‚Äì art infrastructure for professional aspirants hailing from both rural and urban areas. 
‚Ä¢	Impacting technical and management education to encourage independent thinking, develop strong domain of knowledge, own contemporary skills and positive attitudes towards ostilic growth of young minds. 
‚Ä¢	Evolving institution into a center of excellence and research. 
 
QUALITY POLICIES 
 
       Sri Venkateswara College Of Engineering And Technology strides towards excellence by adopting a system of quality policies and processes with continued improvements to enhance student skills and talent for their exemplary contribution to the society, the nation and the word. 
 
 
VISION AND MISSION OF THE DEPARTMENT UNDER R20 REGULATIONS 
VISION: 
 
‚Ä¢ To achieve excellent standard of quality education by suing latest tools in Artificial Intelligence and disseminating innovations to relevant areas. 
MISSION 
 
‚Ä¢	To develop professionals who are skilled in Artificial Intelligence. 
‚Ä¢	Impact rigorous training to generate knowledge through the state -of -the ‚Äì art concepts and technologies in Artificial Intelligence. 
‚Ä¢	Establish centers of excellence in leading areas of computing and artificial intelligence to inculcate strong to work with a commitment to the progress of the nation. 
 
PROGRAM EDUCATIONAL OBJECTIVES(PEOs): 
 
PEO1: 
To be able to solve wide range of computing related problems to cater to the needs of industry and society. 
 
PEO2: 
Enable students to build intelligent machines and applications with a cutting ‚Äì edge combinations of machine learning, analytics, and visualization. 
PEO3: 
Produce graduates having professional competence through life-long learning such as advanced degrees, professional skills and other professional activities related globally to engineering & society. 
 
 
 
 
PROGRAM SPECIFIC OUTOCOMES(PSOs): 
 
PSO1: 
Should have an ability to apply technical knowledge and usage of modern hardware and software tools related AI for solving real world problems. 
 
PSO2: 
Should have the capability to develop many successful applications based on machine learning methods, AI methods in different fields, including neural networks, signal processing, and data mining. 
 	 ‚ÄÉ
 
CERTIFICATE 
 
 
 
  
ACKNOWLEDGEMENT 
 
A grateful thanks to Dr. Ravuri Venkata swamy, Chairman of Sri Venkateswara College of Engineering & Technology for providing education in their esteemed institution. 
 
I wish to record my deep sense of gratitude and profound thanks to our beloved Vice Chairman, Sri Ravuri Venkata Srinivas for his valuable support throughout the course. 
 
I express our sincere thanks to Dr. M. MOHAN BABU, our beloved principal for his encouragement and suggestion during the course of study. 
 
 
With the deep sense of gratefulness, I acknowledge Dr. M. LAVANYA, Head of the Department, Computer Science Engineering (AI), for giving us inspiring guidance in undertaking internship. 
 
I express our sincere thanks to the Dr. K. ANJANEYULU, internship coordinator, for his keen interest, stimulating guidance, constant encouragement with our work during all stages, to bring this report into fruition. 
 
Finally, I would like to express my sincere thanks to all teaching, non-teaching faculty members, our parents, friends and for all those who have supported us to complete the internship successfully. 
 
 
                                                                                                                          
                                                                                                                Name: BOGOLU LAVANYA 
                                                                                                                Roll No: 22781A3107 
 
 
 
 
ABSTRACT 
 
 
Java is a versatile, object-oriented programming language widely used in developing platform- independent applications. Known for its "Write Once, Run Anywhere" capability, Java has become a cornerstone for building scalable, secure, and high-performance applications. 
 
This language offers a rich set of libraries and frameworks, enabling developers to create everything from mobile applications to large-scale enterprise systems. Java‚Äôs robustness, ease of use, and extensive community support make it an ideal choice for both beginner and experienced developers. 
 
Through its powerful features like memory management, multithreading, and rich APIs, Java continues to be a critical technology for various domains including web development, data processing, and cloud computing. 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

‚Ä¢ 
‚Ä¢ 
‚Ä¢ 
‚Ä¢ 
‚Ä¢ 
 	Software and Hardware Requirements 
System Design Overview 
Implementation (Source Code) 
Sample input and output 
Conclusion 
9 
 
  
                WEEKLY OVERVIEW OF INTERNSHIP ACTIVITIES  
 
 
WEEK - 1: Java Environment Setup and Core Fundamentals 
 
DAY 		
	DATE 	TOPIC/CONCEPT COVERED 
		
Saturday 	05/7/25 	Windows Setup and Introduction to Java 
Monday 	07/7/25 	Linux Setup and Your First Java App 
Tuesday 	08/7/25 	Variables and Data Types 
Wednesday 	09/7/25 	Taking User Input and Operators 
Thursday 	10/7/25 	Conditionals and Overview 
Friday 	11/7/25 	Iterators and Arrays 
 
WEEK - 2: Intermediate Java and OOP Concepts 
 
DAY 		
	DATE 	TOPIC/CONCEPT COVERED 
		
Saturday 	12/7/25 	Strings 
Monday 	14/7/25 	Methods 
Tuesday 	15/7/25 	Exception Handling and Overview 
Wednesday 	16/7/25 	Classes and Objects 
Thursday 	17/7/25 	Constructors, Getter and Setter 
Friday 	18/7/25 	Inheritance 
 
 
WEEK - 3: Advanced OOP, Collections, and File I/O 
 
DAY 	DATE 	TOPIC/CONCEPT COVERED 
		
Saturday 	19/7/25 	Polymorphism 
Monday 	21/7/25 	Abstract keyword 
Tuesday 	22/7/25 	Interface 
Wednesday 	23/7/25 	Static Keyword 
Thursday 	24/7/25 	Collections 
Friday 	25/7/25 	File Handling 
 
WEEK - 4: Introduction to Desktop Apps and Layouts (JavaFX) 
 
DAY 	DATE 	TOPIC/CONCEPT COVERED 
		
Saturday 	26/7/25 	Connect Four Game UI 
Monday 	28/7/25 	Overview 
Tuesday 	29/7/25 	First Desktop App 
Wednesday 	30/7/25 	Layouts 
Thursday 	31/7/25 	Grid PLane 
Friday 	01/8/25 	Menu 
  
 
 
 
 
 
MONTH 2 (02 Aug ‚Äì 05 Sep 2025) ‚Äì PROJECT PHASE 
 
Project Title: Vendor Contract Management System using Java and MongoDB 
 
Activities: 
‚Ä¢	Requirement Analysis and System Design 
‚Ä¢	Database Schema Design (MongoDB) 
‚Ä¢	Implementation of Vendor and Contract Modules 
‚Ä¢	CRUD Operations Integration 
‚Ä¢	Testing and Debugging 
‚Ä¢	Report Preparation & Documentation 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 	 
CHAPTER 1: 
GETTING STARTED WITH JAVA 
 
Introduction 
The Java Development Kit (JDK) is software used for Java programming, along with the Java Virtual Machine (JVM) and the Java Runtime Environment (JRE). The JDK includes the compiler and class libraries, allowing developers to create Java programs executable by the JVM and JRE. 
In this tutorial, you will learn to install the Java Development Kit on Windows. 
 
 
 
Prerequisites 
‚Ä¢	A system running Windows 10. 
‚Ä¢	A network connection. 
‚Ä¢	Administrator privileges. 
 
Note: Develop your core app services on PNAP's Bare Metal Cloud servers to ensure superior performance. It's cloud native and the perfect environment for the entire SDLC. 
Check if Java Is Installed 
Before installing the Java Development Kit, check if a Java version is already installed on Windows. Follow the steps below: 
java -version 
 
 
The command outputs the Java version on your system. If Java isn't installed, the output is a message stating that Java isn't recognized as an internal or external command. 
Note: If you need to set up Java on a different system, check out our tutorials for installing Java on Ubuntu, Fedora, Raspberry Pi, CentOS 8, and CentOS 7. 
Download Java for Windows 10 
Download the latest Java Development Kit installation file for Windows 10 to have the latest features and bug fixes. 
1.	Using your preferred web browser, navigate to the Oracle Java Downloads page. 
2.	On the Downloads page, click the x64 Installer download link under the Windows category. At the time of writing this article, Java version 17 is the latest long-term support Java version. 
 
 
Wait for the download to complete. 
 
Install Java on Windows 10 
After downloading the installation file, proceed with installing Java on your Windows system.  
 
 
 
 
Follow the steps below: 
Step 1: Run the Downloaded File 
Double-click the downloaded file to start the installation. 
Step 2: Configure the Installation Wizard 
After running the installation file, the installation wizard welcome screen appears. 
 
1.	Click Next to proceed to the next step. 
 
 
2.	Choose the destination folder for the Java installation files or stick to the default path. Click Next to proceed. 
  
3.	Wait for the wizard to finish the installation process until the Successfully Installed message appears. Click Close to exit the wizard. 
 
 
 
INTRODUCTION TO JAVA 
 
Java is one of the most popular and widely used programming languages in the world. It was developed by James Gosling and his team at Sun Microsystems in 1995, and later acquired by Oracle Corporation. Java is an object-oriented, platform-independent, and secure programming language used for developing a wide range of applications ‚Äî from desktop and mobile apps to web-based and enterprise solutions. 
Key Features of Java 
1. Simple and Easy to Learn Java‚Äôs syntax is clean and straightforward, making it easy for beginners to learn and understand. It removes many complex features of other languages like pointers and multiple inheritance. 
2. Object-Oriented Programming (OOP) 
Everything in Java is treated as an object. This promotes code reusability, flexibility, and easy maintenance through concepts like classes, objects, inheritance, polymorphism, abstraction, and encapsulation. 
3. Platform Independent One of Java‚Äôs most important features is its ‚ÄúWrite Once, Run Anywhere‚Äù (WORA) capability. Java programs are compiled into bytecode, which can run on any machine that has the Java Virtual Machine (JVM). 
4. Robust and Secure 
Java provides strong memory management, exception handling, and security features such as runtime checking and access control to ensure safe execution of code. 
5. Multithreaded 
Java supports multithreading, allowing multiple parts of a program to run simultaneously. This improves performance, especially in applications like gaming or animations. 
6. High Performance 
Java‚Äôs performance is enhanced by its Just-In-Time (JIT) compiler, which converts bytecode into native machine code at runtime. 
7. Distributed and Network-Centric 
Java is designed for networked environments, making it suitable for building distributed applications that can communicate over networks easily. 
8. Rich API and Libraries 
Java offers a vast collection of built-in classes and methods that simplify development ‚Äî including libraries for data structures, networking, GUI development, and database connectivity. 
 
 
 
 
 
 
 
 
 
 
CHAPTER 2: LEVERAGING  BASIC CONCEPTS 
 
 
     VARIABLE AND DATA TYPES: 
 
  
 
 
 
 
EXAMPLE CODE FOR VARIABLES AND DATA TYPES: 
 
// Example program to demonstrate variables in Java public class VariablesExample {     public static void main(String[] args) { 
         
        // Declaring and initializing variables         int age = 21;                  // Integer variable         double salary = 55000.75;      // Floating-point variable         char grade = 'A';              // Character variable         boolean isJavaFun = true;      // Boolean variable 
        String name = "Lavanya";       // String variable 
 
        // Displaying the values of variables 
        System.out.println("Name: " + name); 
        System.out.println("Age: " + age); 
        System.out.println("Salary: " + salary); 
        System.out.println("Grade: " + grade); 
        System.out.println("Is Java Fun? " + isJavaFun); 
    } } 
 
 
 
 
 
 
TAKING USER INPUT:  
 
 
 
 
  
EXAMPLE CODE FOR USER INPUT: 
 
package com.internshala.javaapp; import java.util.Scanner; public class Main { public static void main(String[] args) {  String name;  int population; 
float populationDensity;    double GDP; 
      char currency; // '$' 
	boolean isSecular; 	 
Scanner scanner = new Scanner(System.in); 
	ystem.out.println("Enter your country name: "); 	 
name = scanner.nextLine(); 
 
	System.out.println("Enter population: "); 	 
population = scanner.nextInt(); 
 
	System.out.println("Enter currency symbol: "); 	 
currency = scanner.next().charAt(0); 
                     System.out.println("Your country name is: " + name);    
                     System.out.println("The population of the country is : " + population); 
                             System.out.println("The currency symbol is: " + currency); 
 
 
scanner.close(); 
} 
 
 
} 
OPERATORS: 
 
  
 
 
  
 
 
 
  
 
  
 
 
 
 
 
 
 
 
 
  
 
CONDITIONALS: 
 
  
 
 
 
 
 
 
 
 
 
  
 
 
ITERATORS:
 
 
ARRAYS: 
 
  
 
 
 
 
 
   EXAMPLE PROGRAM FOR 1D ARRAY: 
 
package com.internshala.javaapp; public class 
Main { 
public static void main(String[] args) { 
 
// WAP to print all numbers in array along with this find out sum of all elements in the array. 
 
	// Index 	0 	1 2  3 	 
 
int[] myFirstArray = { 20, 19, 48, 7 }; int sum = 0; 
for (int i = 0; i < myFirstArray.length; i++) { 
 
sum += myFirstArray[i]; 
System.out.println(myFirstArray[i]); 
} 
System.out.println("Sum of firstArray: " + sum); 
 
// Second way to declare an Array  float[] mySecondArray = new float[3]; 
       mySecondArray[0] = 34.2f;  
 
	      mySecondArray[1] = 4.6f; 	 
      mySecondArray[2] = 78.11f; 
 
float sumOfNumbers = 0; 
	for (float num: mySecondArray) { 	// For Each Loop 	 
    sumOfNumbers += num; 
System.out.println(num) 
 
 
                } 
System.out.println("Sum of secondArray: " + sumOfNumbers); 
} 
 
 STRINGS: 
 
EXAMPLE CODE FOR STRING: 
Package com.internshala.javaapp; public class Main { public static void main(String[] args) { 
// String Handling 
	// Index 	0 	1 	2 	3 	4 	5 	6 	--> length of 7 
char[] myArray = { 'W', 'e', 'l', 'c', 'o', 'm', 'e' }; 
// Using Literals to create String 
String firstString = "Welcome"; // S1 
String secondString = "Welcome";// S1 
// Using new keyword 
String thirdString = new String("Welcome");  
	// S2    System.out.println(firstString == secondString); 	 
// Compare Two Objects .. true .. S1 ==S1 System.out.println(firstString == thirdString);  
// Compare Two Objects .. false .. 
System.out.println(firstString.equals(thirdString)); 
// Compare two values .. true "Welcome" == "Welcome" System.out.println(myArray.length); // 7 
System.out.println(firstString.length());  // 7 
System.out.println(firstString.charAt(6)); //  
System.out.println(firstString.toUpperCase());  
 
// WELCOME      System.out.println(firstString.toLowerCase()); // welcome 
System.out.println(firstString.contains("come")); // true 
	System.out.println(firstString + " to Internshala"); 	// Welcome to Internshala 
System.out.println(firstString.concat(" to Internshala")); // Welcome to Internshala 
} 
} 
 
 
 
 
METHODS: 
 
Method in Java 
In general, a method is a way to perform some task. Similarly, the method in Java is a collection of instructions that performs a specific task. It provides the reusability of code. We can also easily modify code using methods. In this section, we will learn what is a method in Java, types of methods, method declaration, and how to call a method in Java. 
 
What is a method in Java? 
A method is a block of code or collection of statements or a set of code grouped together to perform a certain task or operation. It is used to achieve the reusability of code. We write a method once and use it many times. We do not require to write code again and again. It also provides the easy modification and readability of code, just by adding or removing a chunk of code.  
 
  
Method Signature: Every method has a method signature. It is a part of the method declaration. It includes the method name and parameter list. 
 
Access Specifier: Access specifier or modifier is the access type of the method. It specifies the visibility of the method. Java provides four types of access specifier: 
 
o	Public: The method is accessible by all classes when we use public specifier in our application. 
o	Private: When we use a private access specifier, the method is accessible only in the classes in which it is defined. 
o	Protected: When we use protected access specifier, the method is accessible within the 
same package or subclasses in a different package. 
o	Default: When we do not use any access specifier in the method declaration, Java uses default access specifier by default. It is visible only from the same package only. 
Return Type: Return type is a data type that the method returns. It may have a primitive data type, object, collection, void, etc. If the method does not return anything, we use void keyword. 
 
Method Name: It is a unique name that is used to define the name of a method. It must be corresponding to the functionality of the method. Suppose, if we are creating a method for subtraction of two numbers, the method name must be subtraction(). A method is invoked by its name. 
 
Types of Method 
There are two types of methods in Java: 
 
o	Predefined Method  o 	User-defined Method 
      Predefined Method 
In Java, predefined methods are the method that is already defined in the Java class libraries is known as predefined methods. It is also known as the standard library method or built-in method. We can directly use these methods just by calling them in the program at any point. 
Demo.java 
 
1.	public class Demo 
2.	{ 
3.	public static void main(String[] args) 
4.	{ 
5.	// using the max() method of Math class 
6.	System.out.print("The maximum number is: " + Math.max(9,7)); 
7.	} 
8.	} 
User-defined Method 
How to The method written by the user or programmer is known as a user-defined method. These methods are modified according to the requirement. 
Create a User-defined Method 
 
Let's create a user defined method that checks the number is even or odd. First, we will define the method. 
1.	//user defined method 
2.	public static void findEvenOdd(int num) 
3. { 
4.	//method body 
5.	if(num%2==0) 
6.	System.out.println(num+" is even"); 
7.	else 
8.	System.out.println(num+" is odd"); 
9. } 
 
EXCEPTION HANDLING: 
The Exception Handling in Java is one of the powerful mechanism to handle the runtime errors so that the normal flow of the application can be maintained. 
 
In this tutorial, we will learn about Java exceptions, it's types, and the difference between checked and unchecked exceptions. 
 
What is Exception in Java? 
Dictionary Meaning: Exception is an abnormal condition. 
 
In Java, an exception is an event that disrupts the normal flow of the program. It is an object which is thrown at runtime. 
Advantage of Exception Handling 
 
The core advantage of exception handling is to maintain the normal flow of the application. An exception normally disrupts the normal flow of the application; that is why we need to handle exceptions. Let's consider a scenario‚Ä¶. 
statement 1;  statement 2; 
1.	statement 3; 
2.	statement 4; 
3.	statement 5;   //exception occurs 
4.	statement 6; 
5.	statement 7; 
6.	statement 8; 
7.	statement 9; 
8.	statement 10; 
Suppose there are 10 statements in a Java program and an exception occurs at statement 5; the rest of the code will not be executed, i.e., statements 6 to 10 will not be executed. However, when we perform exception handling, the rest of the statements will be executed. That is why we use exception handling in Java CODE: 
 
1.	public class JavaExceptionExample{ 
2.	public static void main(String args[]){ 
3.	try{ 
4.	//code that may raise exception 
5.	int data=100/0; 
6.	}catch(ArithmeticException e){System.out.println(e);} 
7.	//rest code of the program 
8.	System.out.println("rest of the code..."); 
9.	} 
10.	} 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
CHAPTER 3: ADVANCED OOP, COLLECTIONS, AND 
FILE O/P 
 
 
 CLASSES AND OBJECTS:     
  
 What is a Class? 
          A class in Java is a blueprint or template that defines the structure and behavior (data and        methods) of objects. 
It represents a group of related variables (called fields) and functions (called methods) that operate on those variables. 
üëâ In simple words: 
A class is like a ‚Äúdesign‚Äù or ‚Äúplan,‚Äù and an object is the ‚Äúreal thing‚Äù built from that design. 
EXAMPLE: 
 
class Car { 
    // Fields 
    String brand;     String color;     int speed; 
 
    // Method 
    void displayDetails() { 
        System.out.println("Brand: " + brand); 
        System.out.println("Color: " + color); 
        System.out.println("Speed: " + speed + " km/h"); 
    } 
} 
What is an Object? 
An object is an instance of a class ‚Äî it is created in memory when you use the new keyword. 
Each object has its own copy of the class‚Äôs variables and can use its methods. 
EXAMPLE: 
 
public class Main { 
    public static void main(String[] args) { 
        // Creating an object of Car class 
        Car myCar = new Car(); 
 
        // Assigning values         myCar.brand = "Tesla";         myCar.color = "Red"; 
        myCar.speed = 120; 
 
        // Calling method         myCar.displayDetails();     }}   
 
CONSTRUCTORS: 
 
A constructor in Java is a special method that is used to initialize objects. The constructor is called when an object of a class is created. It can be used to set initial values for object. 
 
Create the constructor: 
// Create a Main class public class Main { int x; // Create a class attribute 
// Create a class constructor for the Main class public Main() { 	x = 5; // Set the initial value for the class attribute x 
} public static void main(String[] args) { 
Main myObj = new Main(); // Create an object of class Main (This will call the constructor) 
System.out.println(myObj.x); // Print the value of x 
} 
} 
// Outputs 5 
GET AND SET:  
 
The get method returns the variable value, and the set method sets the value. 
Syntax for both is that they start with either get or set, followed by the name of the variable, with the first letter in upper case: 
 Example 
public class Person { private String name; // private = restricted access 
// Getter public String getName() { return name; 
} // Setter  public void setName(String newName) 
	{ 	this.name = newName; 
} } 
 
INHERITANCE IN JAVA:  
Inheritance in Java is a mechanism in which one object acquires all the properties and behaviors of a parent object. It is an important part of OOPs (Object Oriented programming system). 
The idea behind inheritance in Java is that you can create new classes 
that are built upon existing classes. When you inherit from an existing class, you can reuse methods and fields of the parent class. Moreover, you can add new methods and fields in your current class also. 
Inheritance represents the IS-A relationship which is also known as a parentchild relationship. 
Terms used in Inheritance o Class: A class is a group of objects which have common properties. It is a template or blueprint from which objects are created. o Sub Class/Child Class: Subclass is a class which inherits the other class. It is also called a derived class, extended class, or child class. 
o	Super Class/Parent Class: Superclass is the class from where a subclass inherits the features. It is also called a base class or a parent class. 
o	Reusability: As the name specifies, reusability is a mechanism which facilitates you to reuse the fields and methods of the existing class when you create a new class. You can use the same fields and methods already defined in the previous class. 
 
The syntax of Java Inheritance 
 
1.	class Subclass-name extends Superclass-name 
2.	{ 
3.	//methods and fields 
	4. 	} 
 
The extends keyword indicates that you are making a new class that derives from an existing class. The meaning of "extends" is to increase the functionality. 
 
JAVA POLYMORPHISM 
Polymorphism means "many forms", and it occurs when we have many classes that are related to each other by inheritance. 
 
Like we specified in the previous chapter; Inheritance lets us inherit attributes and methods from another class. Polymorphism uses those methods to perform different tasks. This allows us to perform a single action in different ways. 
 
For example, think of a superclass called Animal that has a method called animalSound(). Subclasses of Animals could be Pigs, Cats, Dogs, Birds - And they also have their own implementation of an animal sound (the pig oinks, and the cat meows, etc.): 
 
 Example 
class Animal { public void animalSound() { System.out.println("The animal makes a sound"); 
} } class Pig extends Animal { public void animalSound() { 
System.out.println("The pig says: wee wee"); 
} } class Dog extends Animal { public void animalSound() { 
System.out.println("The dog says: bow wow"); 
} 
} 
ABSTRACT CLASSES AND METHODS: 
 
Data abstraction is the process of hiding certain details and showing only essential information to the user. 
Abstraction can be achieved with either abstract classes or interfaces (which you will learn more about in the next chapter). 
 
The abstract keyword is a non-access modifier, used for classes and methods: 
 
‚Ä¢	Abstract class: is a restricted class that cannot be used to create objects (to access it, it must be inherited from another class). 
‚Ä¢	Abstract method: can only be used in an abstract class, and it does not have a body. The body is provided by the subclass (inherited from). 
 
An abstract class can have both abstract and regular methods: 
abstract class Animal { public abstract void 
animalSound();  public void sleep() { 
System.out.println("Zzz"); 
} 
}From the example above, it is not possible to create an object of the Animal class: Animal myObj = new Animal(); // will generate an error 
An interface is a completely "abstract class" that is used to group related methods with empty bodies: 
 
 Example 
// interface interface Animal { public void animalSound(); // interface method (does not have a body) public void run(); // interface method (does not have a body) 
} 
 
INTERFACE: 
 
To access the interface methods, the interface must be "implemented" (kinda like inherited) by another class with the implements keyword (instead of extends). The body of the interface method is provided by the "implement" class: 
 
 Example 
// Interface interface Animal { public void animalSound(); // interface method (does not have a body) public void sleep(); // interface method (does not have a body) 
} 
// Pig "implements" the Animal interface class Pig implements Animal { public void animalSound() { 
// The body of animalSound() is provided here 
System.out.println("The pig says: wee wee"); 
} public void sleep() { // The body of sleep() is provided here 
System.out.println("Zzz"); 
} 
} class Main { public static void main(String[] args) { 	Pig myPig = new Pig(); // Create a Pig object myPig.animalSound(); 	myPig.sleep(); 
}} 
                                                                                   
CHAPTER 4 : 
 
PROJECT 
 
VENDOR CONTRACT MANAGEMENT SYSTEM 
 
Introduction: 
 
The Vendor Contract Management System is a console-based Java project designed to manage vendors and their contracts efficiently. It uses MongoDB as the database to store and retrieve information. The system allows users to add, view, update, and delete vendor and contract details easily. It also maintains a clear link between vendors and their contracts. This project helps reduce manual work, ensures data accuracy, and makes contract management faster and more organized. 
 
Aim: 
 
The main aim of the Vendor Contract Management System is to develop a console-based Java   application that efficiently manages vendors and their associated contracts using MongoDB as the backend database. The system aims to automate vendor and contract record-keeping, minimize manual errors, and provide a structured way to view, update, and maintain contract information for organizations. 
 
Objectives: 
 
1.	To develop a console-based Java system for managing vendors and contracts using MongoDB. 
2.	To implement full CRUD operations for vendors and contracts. 
3.	To establish and manage the relationship between vendors and their contracts. 
4.	To auto-generate unique IDs for vendors and contracts. 
5.	To validate user inputs for data accuracy. 
6.	To provide search and filter options for quick data retrieval. 
7.	To generate summary reports such as active and expired contracts. 
8.	To enable optional data export to CSV format. 
9.	To ensure proper error handling and smooth program execution. 
 
Software and Hardware Requirements 
 
Software Requirements 
‚Ä¢	Java (JDK 17 or above) 
‚Ä¢	MongoDB Database 
‚Ä¢	Code Editor (VS Code / IntelliJ / Eclipse) 
‚Ä¢	MongoDB Java Driver JAR files 
‚Ä¢	Windows 10 or above 
Hardware Requirements 
‚Ä¢	Processor: Intel i3 or higher 
‚Ä¢	RAM: 4 GB or more 
SOUCE CODE: 
 
Contract.java 
  
public class Contract {     private String contractId;     private String vendorId;     private String startDate;     private String endDate;     private double amount; 
    private String status; 
 
    public Contract(String contractId, String vendorId, String startDate, String endDate, double amount, String status) {         this.contractId = contractId;         this.vendorId = vendorId;         this.startDate = startDate;         this.endDate = endDate;         this.amount = amount;         this.status = status; 
    } 
 
    public String getContractId() { return contractId; }     public String getVendorId() { return vendorId; }     public String getStartDate() { return startDate; }     public String getEndDate() { return endDate; }     public double getAmount() { return amount; }     public String getStatus() { return status; } 
} 
 
Vendor.java 
 
public class Vendor {     private String vendorId;     private String name;     private String contact;     private String email; 
    private String address; 
 
    public Vendor(String vendorId, String name, String contact, String email, String address) {         this.vendorId = vendorId;         this.name = name;         this.contact = contact;         this.email = email; 
        this.address = address; 
    } 
 
    public String getVendorId() { return vendorId; }     public String getName() { return name; }     public String getContact() { return contact; }     public String getEmail() { return email; }     public String getAddress() { return address; } 
} 
 
 
VendorContractManagementSystem.java 
 
import com.mongodb.client.*; import com.mongodb.client.model.Updates; import org.bson.Document; import java.util.Scanner; import java.text.ParseException; 
import java.text.SimpleDateFormat; 
import java.util.Date; 
 
public class VendorContractManagementSystem { 
 
    static MongoClient mongoClient = MongoClients.create("mongodb://localhost:27017");     static MongoDatabase database = mongoClient.getDatabase("VendorContractDB");     static MongoCollection<Document> vendorCollection = database.getCollection("vendors");     static MongoCollection<Document> contractCollection = database.getCollection("contracts");     static Scanner sc = new Scanner(System.in); 
 
    public static void main(String[] args) { 
        int choice;         do { 
            System.out.println("\n--- Vendor Contract Management ---"); 
            System.out.println("1. Vendor Management"); 
            System.out.println("2. Contract Management"); 
            System.out.println("3. Show Vendors with Contracts"); 
            System.out.println("0. Exit");             System.out.print("Enter choice: "); 
            choice = sc.nextInt(); 
            sc.nextLine(); // consume newline 
 
            switch (choice) {                 case 1 -> vendorMenu();                 case 2 -> contractMenu();                 case 3 -> showVendorsWithContracts();                 case 0 -> System.out.println("Exiting..."); 
                default -> System.out.println("Invalid choice!"); 
            } 
        } while (choice != 0); 
    } 
 
    // -------------------- Vendor Menu --------------------     static void vendorMenu() {         int choice; 
        do { 
            System.out.println("\n--- Vendor Management ---"); 
            System.out.println("1. Add Vendor"); 
            System.out.println("2. View All Vendors"); 
            System.out.println("3. Update Vendor"); 
            System.out.println("4. Delete Vendor"); 
            System.out.println("0. Back to Main Menu");             System.out.print("Enter choice: "); 
            choice = sc.nextInt(); 
            sc.nextLine(); 
 
            switch (choice) {                 case 1 -> addVendor();                 case 2 -> viewAllVendors();                 case 3 -> updateVendor();                 case 4 -> deleteVendor(); 
                case 0 -> {} 
                default -> System.out.println("Invalid choice!"); 
            } 
        } while (choice != 0); 
   } 
   // -------------------- Contract Menu --------------------    static void contractMenu() { 
       int choice; 
       do { 
           System.out.println("\n--- Contract Management ---"); 
    System.out.println("1. Add Contract"); 
    System.out.println("2. View All Contracts"); 
    System.out.println("3. Update Contract"); 
    System.out.println("4. Delete Contract"); 
    System.out.println("0. Back to Main Menu");            System.out.print("Enter choice: "); 
           choice = sc.nextInt(); 
           sc.nextLine(); 
 
            switch (choice) {                 case 1 -> addContract();                 case 2 -> viewAllContracts();                 case 3 -> updateContract();                 case 4 -> deleteContract(); 
                case 0 -> {} 
                default -> System.out.println("Invalid choice!"); 
            } 
        } while (choice != 0); 
    } 
 
    // -------------------- CRUD Operations -------------------- 
 
    static void addVendor() {         String id = generateVendorId(); 
        System.out.println("Vendor ID auto-generated: " + id); 
        System.out.print("Name: "); String name = sc.nextLine(); 
        System.out.print("Contact: "); String contact = sc.nextLine(); 
        System.out.print("Email: "); String email = sc.nextLine(); 
        System.out.print("Address: "); String address = sc.nextLine(); 
 
        Document doc = new Document("vendorId", id) 
                .append("name", name) 
                .append("contact", contact) 
                .append("email", email) 
                .append("address", address); 
 
        vendorCollection.insertOne(doc); 
        System.out.println("Vendor added successfully!"); 
    } 
 
    static void viewAllVendors() { 
        for (Document vendor : vendorCollection.find()) { 
            System.out.println("\nVendor ID: " + vendor.getString("vendorId")); 
            System.out.println("Name: " + vendor.getString("name")); 
            System.out.println("Contact: " + vendor.getString("contact")); 
            System.out.println("Email: " + vendor.getString("email")); 
            System.out.println("Address: " + vendor.getString("address")); 
            System.out.println("-------------------------"); 
        } 
    } 
 
    static void updateVendor() { 
        System.out.print("Enter Vendor ID to update: "); String id = sc.nextLine();         Document vendor = vendorCollection.find(new Document("vendorId", id)).first();         if (vendor == null) { System.out.println("Vendor not found!"); return; } 
 
        System.out.print("New Name ("+vendor.getString("name")+"): "); String name = sc.nextLine(); 
       System.out.print("New Contact ("+vendor.getString("contact")+"): "); String contact = sc.nextLine(); 
       System.out.print("New Email ("+vendor.getString("email")+"): "); String email = sc.nextLine();        System.out.print("New Address ("+vendor.getString("address")+"): "); String address = sc.nextLine(); 
       vendorCollection.updateOne(new Document("vendorId", id),                new Document("$set", new Document() 
                       .append("name", name.isEmpty()?vendor.getString("name"):name) 
                .append("contact", contact.isEmpty()?vendor.getString("contact"):contact) 
                .append("email", email.isEmpty()?vendor.getString("email"):email) 
                .append("address", address.isEmpty()?vendor.getString("address"):address) 
        )); 
System.out.println("Vendor updated successfully!");    } 
   static void deleteVendor() { 
        System.out.print("Enter Vendor ID to delete: "); String id = sc.nextLine(); 
        vendorCollection.deleteOne(new Document("vendorId", id)); 
        // Also delete contracts linked to this vendor 
        contractCollection.deleteMany(new Document("vendorId", id)); 
        System.out.println("Vendor and linked contracts deleted!"); 
    } 
 
    // -------------------- Contract CRUD -------------------- 
 
    static void addContract() {         String cId = generateContractId(); 
        System.out.println("Contract ID auto-generated: " + cId); 
        System.out.print("Vendor ID: "); String vId = sc.nextLine(); 
 
        Document vendor = vendorCollection.find(new Document("vendorId", vId)).first();         if (vendor == null) { System.out.println("Vendor not found! Add vendor first."); return; } 
 
        System.out.print("Start Date (YYYY-MM-DD): "); String start = sc.nextLine();         if (!validateDate(start)) { System.out.println("Invalid date format!"); return; } 
 
        System.out.print("End Date (YYYY-MM-DD): "); String end = sc.nextLine();         if (!validateDate(end)) { System.out.println("Invalid date format!"); return; } 
 
        System.out.print("Amount: "); double amount = sc.nextDouble(); sc.nextLine();         if (amount <= 0) { System.out.println("Amount must be positive!"); return; } 
 
        System.out.print("Status (Active/Expired/Pending): "); String status = sc.nextLine(); 
 
        Document doc = new Document("contractId", cId) 
                .append("vendorId", vId) 
                .append("startDate", start) 
                .append("endDate", end) 
                .append("amount", amount) 
                .append("status", status); 
 
        contractCollection.insertOne(doc); 
        System.out.println("Contract added successfully!"); 
    } 
 
    static void viewAllContracts() { 
        for (Document contract : contractCollection.find()) { 
            System.out.println("\nContract ID: " + contract.getString("contractId")); 
            System.out.println("Vendor ID: " + contract.getString("vendorId")); 
            System.out.println("Start Date: " + contract.getString("startDate")); 
            System.out.println("End Date: " + contract.getString("endDate")); 
            System.out.println("Amount: " + contract.getDouble("amount")); 
            System.out.println("Status: " + contract.getString("status")); 
            System.out.println("-------------------------"); 
        } 
   } 
   static void updateContract() { 
       System.out.print("Enter Contract ID to update: "); String cId = sc.nextLine();        Document contract = contractCollection.find(new Document("contractId", cId)).first();        if (contract == null) { System.out.println("Contract not found!"); return; } 
System.out.print("New Vendor ID ("+contract.getString("vendorId")+"): "); String vId = sc.nextLine(); 
if (!vId.isEmpty()) { 
    Document vendor = vendorCollection.find(new Document("vendorId", vId)).first();     if (vendor == null) { System.out.println("Vendor not found!"); return; } } 
       System.out.print("New Start Date ("+contract.getString("startDate")+"): "); String start = sc.nextLine();        if (!start.isEmpty() && !validateDate(start)) { System.out.println("Invalid date format!"); return; } 
 
        System.out.print("New End Date ("+contract.getString("endDate")+"): "); String end = sc.nextLine();         if (!end.isEmpty() && !validateDate(end)) { System.out.println("Invalid date format!"); return; } 
 
        System.out.print("New Amount ("+contract.getDouble("amount")+"): "); String amtStr = sc.nextLine();         double amount = amtStr.isEmpty()?contract.getDouble("amount"):Double.parseDouble(amtStr);         if (amount <= 0) { System.out.println("Amount must be positive!"); return; } 
 
        System.out.print("New Status ("+contract.getString("status")+"): "); String status = sc.nextLine(); 
 
        contractCollection.updateOne(new Document("contractId", cId),                 new Document("$set", new Document() 
                        .append("vendorId", vId.isEmpty()?contract.getString("vendorId"):vId) 
                        .append("startDate", start.isEmpty()?contract.getString("startDate"):start) 
                        .append("endDate", end.isEmpty()?contract.getString("endDate"):end) 
                        .append("amount", amount) 
                        .append("status", status.isEmpty()?contract.getString("status"):status) 
                )); 
        System.out.println("Contract updated successfully!"); 
    } 
 
    static void deleteContract() { 
        System.out.print("Enter Contract ID to delete: "); String cId = sc.nextLine();         contractCollection.deleteOne(new Document("contractId", cId)); 
        System.out.println("Contract deleted!"); 
    } 
 
    // -------------------- Vendor-Contract Link -------------------- 
 
    static void showVendorsWithContracts() {         for (Document vendor : vendorCollection.find()) { 
            System.out.println("\nVendor ID: " + vendor.getString("vendorId")); 
            System.out.println("Name: " + vendor.getString("name")); 
 
            FindIterable<Document> contracts = contractCollection.find(                     new Document("vendorId", vendor.getString("vendorId")) 
            ); 
 
            boolean hasContract = false;             for (Document contract : contracts) {                 hasContract = true; 
                System.out.println("\tContract ID: " + contract.getString("contractId")); 
                System.out.println("\tStart: " + contract.getString("startDate")); 
                System.out.println("\tEnd: " + contract.getString("endDate")); 
                System.out.println("\tAmount: " + contract.getDouble("amount")); 
                System.out.println("\tStatus: " + contract.getString("status")); 
            } 
 
            if (!hasContract) System.out.println("\tNo contracts linked.");            System.out.println("-----------------------------"); 
       } 
   } 
   // -------------------- Utilities -------------------- 
   static String generateVendorId() { long count = vendorCollection.countDocuments() + 1; return String.format("V%03d", count); 
}
static String generateContractId() { 
       long count = contractCollection.countDocuments() + 1;        return String.format("C%03d", count); 
   } 
 
    static boolean validateDate(String date) { 
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");         sdf.setLenient(false); 
        try { Date d = sdf.parse(date); return true; }         catch (ParseException e) { return false; } 
    } 
} 
OUTPUT: 
 
  
 
 
  ‚ÄÉ
        LIST OF THE FIGURES:    
 
S.No 	Name of the figure 	Page.No 
01. 	Internship Certificate 	05 
02. 	Fig 1.1 java installation 	13 
03. 	Fig 1.2 java version checking 	14 
04. 	Fig 1.3: java download 	14 
05. 	Fig 1.4,1.5: jdk 	15 
06. 	Fig 2.1.1: variables & datatypes 	18 
07. 	Fig 2.1.2: integer type 	18 
08. 	Fig 2.1.3: float type 	19 
09. 	Fig 2.2.1: user input 	20 
10. 	Fig 2.3.1: (OR, AND operator) 	21 
11. 	Fig 2.3.2: NOT operator 	22 
12. 	Fig 2.3.3: increment/decrement operator 	22 
13. 	Fig 2.3.4: Assignment & relational operator 	23 
14. 	Fig 2.3.5: Arithmetic difference 	23 
15. 	Fig 2.4.1: Conditional Statement 	24 
16. 	Fig 2.4.2: if/else 	25 
17. 	Fig 2.5.1: Iterator 	25 
18. 	Fig 2.6.1: Arrays 	26 
19. 	Fig 2.7.1: Strings 	28 
20. 	Fig 2.8.1: Methods 	30 
21. 	Fig 4.1: input/output 	45 
22. 	Fig 4.2: mongo db output 	46 
 
  
